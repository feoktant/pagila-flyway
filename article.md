# Разбираемся с Flyway и Postgres на примере Pagila

Большинство статей, которые мне попадаются по Flyway заканчиваются на HelloWorld. В них частенько нет сложных конструкций и best practices. Как итог, новичок вынужден набивать свои собственные шишки и переизобретать уже известные механизмы.
Я хочу на примере Postgres показать свой опыт как готовить Flyway. А что бы было не так скучно, возьмем учебную БД Pagila, напишем для неё скрипты, рассмотрим что потеряли в процессе портирования из MySQL Sakila, и напишем недостающие части.
Как сайд эффект, выложим обновленный скрипт Pagila.


##### Pagila - что за зверь?

Pagila - это порт на Postgres учебной БД Sakila для MySQL. В базе реализован магазин аренды DVD дисков. Это старая БД из 2006-го года, которую портировали в районе 2017-го. Но главне - для неё есть неплохая документация, и она довольно известна.

Если смотреть с точки зрения контекста, базу можно условно разделить на три составляющие:
- фильмы
- локация
- магазин

В учебных целях все три контекста можно расположить в разных схемах, но мы этого делать не будем, оставив MySQL-подобный стиль.

Всего у нас:
- 15 таблиц, одна партиционирована
- 7 вьюх
- 8 хранимок
- много других интересностей, о которых поговорим отдельно

Именование primary и foreign key одинаковое. Сделано это для уменьшения boilerplate на джоинах и создании таблиц:

```sql

```

Для аудита изменений во многих таблицах есть поле `last_update`. В Postgres нет из коробки синтаксиса как обновлять поле. Поэтому используется старый трюк с хранимой функцией которая возвращает триггер и триггером на нужном поле. 
-- TODO добавить ссылку на пример этого трюка

Для большинства ключей выбран `SMALLSERIAL`. `UUID` не встречается.

###### Что бросается в глаза

Обидно, но с такой схемой клиент не может взять DVD диск в аренду в одном магазине, и вернуть в другой. Ведь сам клиент привязан к магазину.
Как и работник не может выйти на подмену в другой магазин.
С другой стороны, в базе всего два магазина - один в Австралии, второй в Канаде.

-- sakila official known issue

###### Что упущено\изменено в Pagila

В оригинале, таблицы `store` и `staff` имеют циклические зависимости: работник привязан к магазину, а магазин не может быть без менеджера в этом самом магазине. Это очень интересный кейс, который может многое рассказать о CTE, Deferrable полях, как такие кейсы решать и допустимы ли они. Жалко терять такую тему!


Особые вставки в фильмах были реализованы как массив text[], что не совсем верно, ведь это тоже enum.

Для полнотекстового поиска добавлено поле `tsvector film.fulltext` , но в нём нет название фильма.

`customer.last_update` стал `nullable`, хотя ничего не предвещало.

Специфичные функции `last_date` и `group_concat` были криво портированы в PG.

Имена индексов взяты напрямую из Sakila, хотя можно было их оставить по умолчанию.


Данные вставляются через `copy`, что в целом хорошая практика. Только такой подход не работает с jdbc драйвером Postgres!


#Flyway

Итак, у нас есть два скрипта: pagila-schema.sql и pagila-insert-data.sql. Как мы начнем использовать Flyway?

[В официальной документации](https://flywaydb.org/documentation/existing) описано как начать работать с существующей БД. И я бы не рекомендовал такой вариант. Мы могли бы переименовать pagila-schema.sql в V1__init.sql. В итоге у вас будет огромный скрипт с автогенеренным кодом. В нём тяжело разобраться, еще сложнее править, если понадобиться. Так же, один файл - значит одна транзакция. Если что-то сломается в середине скрипта - вам самим придется разбираться что не так.

Что сделаем мы. Мы начнём писать свой скрипт, будто только придумываем нашу БД. Логичным обходом будет описать часть о фильмах, затем лоакию, магазин и клиентов.

# Выбираем конвенцию именования

Flyway накладывает на нас обязательство, что скрипт имеет вначале имени тэг типа миграции, а за ним номер. Номер является версией миграции. Каждый тул выбирает свой путь. Liquibase не наколадывает никаких ограничений. Play Evolutions ограничивается цифрой. В моей практике, самой удобной конвенцией оказалась взятая из питоновского Django South.

Идея в следующем:
- версия начинается с 1, и возрастает по 1
- для выравнивания названия добавляются нули слева от версии, до четырех символов
- название скрипта привязано к sql\ddl команде, которую этот скрипт выполняет
- в самом скрипте минимальное кол-во команд, идеально - одна:

```
0001_initial.py
0002_auto__add_field_paymenttype_is_active.py
0003_auto__add_field_paymenttype_days_paywall__add_field_paymenttype_days_p.py
0004_auto__add_recurringorder__chg_field_order_create_date.py
```

Почему такой подход оптимальный?
Обычно, вам без разницы что творится в скриптах, пока они работают. 
Жареным пахнет, когда миграции не смогли отработать. 
И в этот момент интересует ровно одно - какой именно скрипт не пробежал, и из-за какой строчки.
Чем меньше эти скрипты - тем лучше для вас. Да, скриптов будет много, ну и пусть:

```
V001__create_table_language.sql
V002__create_domain_year.sql
V003__create_type_feature.sql
V004__create_type_mpaa_rating.sql
V005__create_table_film.sql
```

# Что в скрипте

Вот так будет выглядеть типичный создания таблицы:

```sql
CREATE TABLE language
(
    language_id SMALLSERIAL PRIMARY KEY,
    name        CHAR(20)                  NOT NULL,
    last_update TIMESTAMPTZ DEFAULT now() NOT NULL
);
```

Ни в коем случае не пишите `CREATE TABLE IF NOT EXISTS`! 
Скрипт в V зоне крайне нежелательно делать идемпотентным. 
`IF NOT EXISTS` не проверяет структуру, а только имя.
Скорее всего такое желание связано с уже созданой на проде таблицей.
В этом случаи воспользуйтесь функцией `flyway repair`.

Из этого правила есть одно исключение. 
Если вы запускаете миграции на старте приложения, а в таблице очень много данных. 
И вы решили добавить индекс, то скорее всего будете очень долго ждать окончания миграции.
В таком случаи в PG индексы создают в другом потоке:
```sql
CREATE INDEX CONCURRENTLY idx_film_name ON films (name);
```
В этом случаи позволительно написать
```sql
CREATE INDEX IF NOT EXISTS idx_film_name ON films (name);
```

-- TODO что-то пошло не так, не получилось правильно обновить CONCURRENTLY - не упал.


###### Views и functions

В Flyway повторяющиеся миграции выполняются только после выполнения версионных миграций.
И выполнятся только если файл поменялся.
Это идеально место для наших views, triggers, functions. Но все запросы в этих файлах должны быть идемпотентны,
или говоря проще, иметь `CREATE OR REPLACE`.

Одна засада - PG не умеет `CREATE OR REPLACE TRIGGER`. 
Именно по этой причине, что бы сделать `last_updated` нам понадобиться коллбек.


#### Flyway и темная жизнь коллбеков



https://flywaydb.org/documentation/callbacks.html
